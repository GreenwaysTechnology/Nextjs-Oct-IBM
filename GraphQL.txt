...............................................................................................................................................................................................................	
											GraphQL
...............................................................................................................................................................................................................
What is GraphQL?
	GraphQL is a "new API" standard that provides a more efficient, powerful and flexible alternative to REST.


Drawbacks of REST:

1.Fixed Data structures:
   REST end points return fixed data structure, even if you need only part of the response.
eg:
   /users endpoint might return all user fields (name ,id, email, address etc...), where i need only few fields like name, email.

2.Under fetching:
	 You may need to call multiple endpoints to get all required data for one view.
			/users,/posts,/comments


Why GraphQL or History of GraphQL?

	At its core, GraphQL enables "declarative data fetching" where a client can specify exactly what data it needs from an API.

GraphQL was created by Face book engineers at 2012.
GraphQL was published as open source project on GitHub 2015.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
										GraphQL Implementation
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

GraphQL was created for any language - language independent.

The first implementation GraphQL was available in java script.

The GraphQL implementation is available in two areas

1.Server side
2.Client side

REST API:
Rest spec is based on spec called REST spec
			https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm


GraphQL API :
  It is also based on specification.

Server Side Spec:
    GraphQL Schema language  Specification 

Client Side Spec:
   GraphQL Query language specification     


End point implementation:

REST:

GET /api/products
POST /api/products
PUT /api/products/id
DELETE /api/products/id

GET /api/customers
POST /api/customers
PUT /api/customers/id
DELETE /api/customers/id

GraphQL:

1.Query
   read
2.mutation
   create, update, delete
3.subscription
   Streaming


URL pattern:

REST:
  Each Resource must be identified by unique URL
   Product  - /api/products  -  GET,POST,DELETE,PUT
   Customer  -/api/customers - GET,POST,DELETE,PUT
 
GraphQL :
  For entire application only one URL
   /GraphQL   -POST
 Each resource is called as Object , having methods which are mapped by GraphQL schema language
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									GraphQL Query language
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Talks to GraphQL server application.
How to send and read data from the Server

Concepts:

=>Query encapsulation
=>Query header
=>Query api
=>fields
=>arguments
=>aliases
=>fragments
=>variables
=>directives
=>mutations
=>inline fragments

If you want to learn query language we need api.

i am going to use mock apis.

https://countries.trevorblades.com/

Client tools:

1.post man
2.online browser based tool.
 https://studio.apollographql.com/sandbox/explorer

GraphQL offers many api types

1.READ - GET In Rest - Query in GraphQL 
2.CREATE-POST In REST - mutation in GraphQL
3.UPDATE-PUT In REST - mutation in GraphQL
2.DELETE-DELETE In REST - mutation in GraphQL

We are going to see Read - Query
.........................................................

Client will send request to GraphQL server as like below

Syntax:

1.Selection Set

 SelectionSet  {Selection} => Query Encapsulation.

 SelectionSet could be "query, mutation, subscription"

 query  {Selection}
  or
 mutation  {Selection}
  or
 subscription  {Selection}

Selection:

 apiname (method)
    returns
     -fields
     -fragment spread
     -inline fragment

syntax
  api {
    field1
    fiedl2
    field3
  }

Full eg with selection set

query {
 api {
    field1
    fiedl2  --------------------->Server------response-json
    field3
 }
 }

selection set is "query" - to read 
api - name of the method
fields means the data variables

Operation and Selection Set

//read =>GET
query {
person{
  firstname
  lastname
  age
 }
}

//Write
mutation createUser(params){
  createuser(params) {
     id
     name
  }
}
//streaming
subscription getPriceQuote(params) {
 getPrice(params) {
   price
   name
 }
 
}

Use Case: Simple Query

# Request
query {
  countries {
    name
  }
}
....................................................................................
			    Query Syntax
...................................................................................

1.with query  keyword
query {
  countries {
    name
    code 
    capital
    currency
    emoji
    
  }
}
2.without query keyword
# Request
{
  countries {
    name
    code
    capital
    currency
    emoji
  }
}

3.Query with "Header" - Query Header

 Query header is just dummy name to identify the type of query.
 This looks like "method Name",
 Which can any name.

# Request
query GETCounterInfo {
  countries {
    name
    code
    capital
    currency
    emoji
  }
}
.............................................................................................................................................................................................................
									Nested Fields
.............................................................................................................................................................................................................

REST:

GET	/posts
GET	/posts/1
GET	/posts/1/comments

Here comments is nested data structure.

Use case: Query can ask nested data.

# Request
query GETCounteryInfo {
  countries {
    name
    code
    capital
    currency
    emoji
    states {
      code
      name
    }
  }
}
Response:
"data": {
    "countries": [
      {
        "name": "Andorra",
        "code": "AD",
        "capital": "Andorra la Vella",
        "currency": "EUR",
        "emoji": "ðŸ‡¦ðŸ‡©",
        "states": []
      },
      {
        "name": "United Arab Emirates",
        "code": "AE",
        "capital": "Abu Dhabi",
        "currency": "AED",
        "emoji": "ðŸ‡¦ðŸ‡ª",
        "states": []
      }
   }
}
  .............................................................................................................................................................................................................
							Args and parameters
...............................................................................................................................................................................................................

What if i want to get data based on some condition or conditions
 parameters

Parameters could be hardcoded which is called static params
Parameters could be dynamic  which is called dynamic params

Syntax:
query getUser { 
     user(variableName:value) {
	fields
     }
}
Hardcoded or static parameter
......................................................
eg:
query GETCOUNTRY_BYCODE {
  country(code: "IN") {
    name
    code
    languages {
      name
    }
  }
}
..........................................................................................................................................................................................................	
								  Dynamic parameters
..........................................................................................................................................................................................................

Variables:
 Variables are place holder to have dynamic values which are passed from outside.
  in case of client app, you can pass via programs.

How to use variables?
  Variables are used with "$VariableName" convention.

Steps:
1.Declare variable with data type as part of the query header

Syntax:
 query queryHeader($variableName:DataType){
    apiName(variableName:$variableName){
     fields
   }
 }

query GETCOUNTRY_BYCODE($code: ID!) {
  country(code: $code) {
    name
    code
    languages {
      name
    }
  }
}

Variables:
{
  "code": "AU"
}
Data Types:
 GraphQL provides language independent data types.

Data Types:
Scalar types(primitives)
 ID
 String
 Float
 Int
 Enum
 Boolean

Complex Types(Object Types)
 Objects-Customer, Country, Continent
 Input- Special complex type-Primarily for passing complex input which is eq to DTO


Default Values:

query GETCOUNTRY_BYID($code:ID!="IN") {
  country(code:$code) {
    name
    capital
    currency
    phone
  }
}
with out variables we get India information

with variables we get information based on variable value
variables:
{
  "code": "US"
}

...................................................................................
How to pass complex types or input types?

query:
query GETLANGUAGE_INFO($filter:LanguageFilterInput) {
   languages(filter:$filter){
     code 
     name
   }
}
variables:
{
  "filter": {
    "code": {
      "eq": "en"
    }
  }
}
{
  "data": {
    "languages": [
      {
        "code": "en",
        "name": "English"
      }
    ]
  }
}
..............................................................................................................................................................................................................
									Aliases
............................................................................................................................................................................................................

incase if you want field name differently or if you think that some duplicate fields are coming.

id - userId

Field  aliases gives a dummy name for keys.

without aliases:

{
 user(id:1){
   id
   name
 }
}

Response:
{
 "data" : {
   "user": {
       "id":1,
       "name:: "Subramanian"
     }
 }
}
With aliases:
 {
   subramanian:user(id:1){
     id
     name
    }
 }

{
 "data" : {
   "subramanian": {
       "id":1,
        "name:: "Subramanian"
     }
 }
}

eg:
query GETLANGUAGE_INFO($filter:LanguageFilterInput) {
  mylang:languages(filter:$filter){
     languagecode:code 
     languageName:name
   }
}	
variables:
{
  "filter": {
    "code": {
      "eq": "en"
    }
  }
}
Response:

{
  "data": {
    "mylang": [
      {
        "languagecode": "en",
        "languageName": "English"
      }
    ]
  }
}

..............................................................................................................................................................................................................
										Fragments
.............................................................................................................................................................................................................

What if i have some fields, duplicated across many apis, in order to avoid duplicates fragments are used.

Without Fragment
Syntax:

query {
  user(id:2){
   friends {
      id
      name
      pic
     }
    mutalfriends {
      id
      name
      pic
     }
  }

}
With Fragments:

query {
  user(id:2){
   
     friends {
        ...friendsFields
     }
     mutalfriends {
        ...friendsFields
     }
  }

}
framents friendsFields on User{
      id
      name
      pic
}

..............................................................................................................................................................................................................
										Fragments
.............................................................................................................................................................................................................

What if i have some fields, duplicated across many apis, in order to avoid duplicates fragments are used.

Without Fragment
Syntax:

query {
  user(id:2){
   friends {
      id
      name
      pic
     }
    mutalfriends {
      id
      name
      pic
     }
  }

}
With Fragments:

query {
  user(id:2){
   
     friends {
        ...friendsFields
     }
     mutalfriends {
        ...friendsFields
     }
  }

}
framents friendsFields on User{
      id
      name
      pic
}

eg:
query countries {
  countries {
     ...CountryFields
  }
}
fragment CountryFields on Country{
  code
  name
}
{
  "data": {
    "countries": [
      {
        "code": "AD",
        "name": "Andorra"
      },
      {
        "code": "AE",
        "name": "United Arab Emirates"
      }
    ]
 }
..............................................................................................................................................................................................................
			   						Directives
...........................................................................................................................................................................................................
Directives are built in functions which provides some utilities.

Syntax:
   @directiveName(params)

GraphQL supports two basic directives

1.@include(if:boolean)
2.@skip(if:boolean)
  
  These directives are used to include or exclude fields automatically.

@include(if:Boolean)
   only include "this field" in the result if the arg is true
@skip(if:Boolean)
   exclude /skip "this field" in the result if the arg is true.

Syntax:

query GetProfileHeader{
    getProfile($id:Int,$withFriends:Boolean=false) {
	profile(id:$id) {
	   id
           name
	   friends @include(if:$withFriends)
	
        }

    }
}
eg:
query LanguageInfo($code: ID! = "en", $rtl: Boolean! = false) {
  language(code: $code) {
    name
    native @include(if: $rtl)
  }
}

with skip
query LanguageInfo($code: ID! = "en", $rtl: Boolean! = false) {
  language(code: $code) {
    name
    native @skip(if: $rtl)
  }
}

variables:
{
  "code": "en",
  "rtl": true,
}
Response:

  "data": {
    "language": {
      "name": "English",
      "native": "English"
    }
  }
}
.............................................................................................................................................................................................................
			    					  Mutation
..........................................................................................................................................................................................................

How to send payload (data) to GraphQL api?

create update delete

IN REST

HTTP VERB                   Convention in Server

POST                          save

DELETE			  remove

PUT                           update

In GraphQL there is only one end point ,only one URL


HTTP VERB       GraphQL verb           Convention in Server

POST             mutation                  save                   

PUT              mutation                  update

DELETE       mutation                  remove

GET               query                        read

 -GET-           subscription              read +Streaming
                
                   
Testing:
 
API url :

https://graphqlzero.almansi.me/api
                  
create/insert

mutation CREATEPOST($input:CreatePostInput!){
  createPost(input:$input){
     id 
     title
     body 
  }
}

input:
{
  "input": {
    "title": "Learn graphql",
    "body": "Grapqhl is one the api technology"
  }
}
Response:
{
  "data": {
    "createPost": {
      "id": "101",
      "title": "Learn graphql",
      "body": "Grapqhl is one the api technology"
    }
  }
}

UPDATE:
........
mutation UPDATEPOST($updatedPostId: ID!, $input: UpdatePostInput!) {
  updatePost(id: $updatedPostId, input: $input) {
    id
    title
    body
  }
}

{
  "updatedPostId": "1",
  "input": {
     "title":"Learn grpqhl with Apollo"
  }
}

Response:
{
  "data": {
    "updatePost": {
      "id": "1",
      "title": "Learn grpqhl with Apollo",
      "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
    }
  }
}

Delete:
........
mutation DELETEPOST($id:ID!){
  deletePost(id: $id)
}

{
  "id": "1"
}

Response:
{
  "data": {
    "deletePost": true
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											........................................................................................................................................................................................................................................
						 				Server Side
........................................................................................................................................................................................................................................
					 			  GraphQL API Implementation
.......................................................................................................................................................................................................................................
In order to build apis we have many technologies

1.REST
2.Graphql
3.Grpc

How to build REST apis?

  Restfull webservices are built based on "Resources" in the Problem Domain.

Resources are represented by "Object" which expose Data.

Eg:
 CustomerResource, OrderResource, PaymentResource, CourseResource

Resources are identified by "URL" 
  => /api/customers GET | POST | DELETE | UPDATE

In GraphQL apps are built based on "Models" Which are objects

What ever language we have to think in terms of Objects

...................................................................................
GraphQL Schema Language           Programming Language
....................................................................................
  Schema                                          class or Object

  Customer                                      class Customer {} | let Customer={}

Object shape is described by "Schema". 

Schema is nothing but "Plan"

In GraphQL context, the "Problem domain"  is represented by "Schema language"
.......................................................................................................................................................................................................................................
								SDL - Schema Definition Language
......................................................................................................................................................................................................................................
SDL Core concepts:
............................

1.Type System:
...............
   The Type system defines the platform and language independent data types which describe what data can be quired by client.

Schema Type Systems =========================>Programming language Type System
eg:
   String           =============================>javascript -string

    Int             ==============================>javascript -number

Client                                      						  Server

 Query ----|SDL-----send request --------    |SDL---Models--->biz logic(services| resolvers)-->Data sources

					  |---->java,kotlin,scala,c#,python -jvm
					  |---->js,typescript -node
			SDL implementation|---->
					  |---->
					
	

How to start with SDL?

We need to define type.

syntax:
 type TypeName{
    field:Type
 }
IN SDL, there is root type, every type is derived from the root type.

type Schema {
  query:Query
  mutation:Mutation
  subscription:Subscription
}

type Query{}

type Mutation{}

type Subscription{}

type Query {
  #apis:ReturnType
  hello:String
  #api with arg
  greet(message:String):String
  user:User
  customers:[Customer]
}

type Customer {
  id:ID
  name:String
}

type User{
 id:ID
 name:String
 status:Boolean
}

Client side 

query {
 user {
  id
  status
 }
}


type Mutation { 
 #apis
 createUser(user:User):User
 updateUser(id:ID,user:User):User
}

client
mutation CRATE_USER($user:User) {
  createUser(user:$user){
    id
    status
  }
....................................................................................
				 Data types In SDL
.....................................................................................

1.Scalar Types
   Scalar are like primitives types in the programming languages

1.Int - 32 Bit Signed Integer
2.String - UTF-8 
3.Boolean - true or false
4.Float - Signed Double
5.ID - String but Serialized string - For unique identification

2.Custom Types/Reference Types/ Object types
 Similar to classes in object oriented languages like java, C++,C#

type User {
 id:Int
 firstName:String
 lastName:String
 status:Boolean
 points:Float
}

Object can have other Object Type:
..................................
  Like has a relationship / Dependency injection

type Address { 
 city:String
 state:String
 country:String
}

type User {
 id:Int
 firstName:String
 lastName:String
 status:Boolean
 points:Float
 address:Address
}

Client side 

query {
 user {
  id
  status
  address  {
    city
  }
 }
}

....................................................................................
			Handling null and not null values
....................................................................................

Client query with data

query {
  user {
    name    ------------------> response {name:'Subramanian'}
  }
}

Client query without data

query {
  user {
    name    ------------------> response {name:null}
  }
}

Client is expecting that don't want to include null, if server Includes null , i have to throw an exception.
 =>Not null field

Syntax:
   fieldName:Type!

! -Not Null
type Address { 
 city:String
 state:String
 country:String
}

type User {
 id:Int!
 firstName:String!
 lastName:String!
 status:Boolean
 points:Float
 address:Address
}

Here, id ,firstName, lastName cant be null, if there is null value, the server will throw exception.

....................................................................................
				Collections - List of similar values
....................................................................................
The field may have more than one value

 fieldName:[DataType]

Data Type could be scalar or Object Type

eg:
  products:[Product]
  users:[User]
  skills:[String]
.....................................................................................
			 Collections and Not Null
.....................................................................................
 [{id:1,name:'33'},{id:2,name:'test'},null,{id:3,name:'test'} ]

 languages:[Language!] - Language cant null  [user,,user,null,]

 languages:[Language]! - Array cant null languages: null

 languages:[Language!]! - Language and Array cant be null
........................................................................................................................................................................................................................................
								Advanced Types
.......................................................................................................................................................................................................................................

=>Mutation
=>Subscription
=>Input
=>Enum
=>Union
=>Interface

Mutation:
 For Add,update,delete operations

type Mutation {
  createUser(id:ID,firstName:String,lastName:String,age:Int):User
  updatUser(id:ID!,user:User):User
  removeUser(id:ID):User
}
.......................................................................................................................................................................................................................................
                         									Input
...................................................................................................................................................................................................................................
Input type are special object type that allow you to provide hierarchical data as args to fields

type Mutation {
  createUser(id:ID,firstName:String,lastName:String,age:Int):User
}

In the above code, you  have passed induvial fields, which is not going to be good.

Can i pass user type

type User {
 id:ID
 firstName:String
 lastName:String
 age:Int
}
type Mutation {
  createUser(user:User):User
}

Instead of passing User type, GraphQL offers special object type input

input CreateUserInput {
 id:ID
 firstName:String
 lastName:String
 age:Int
}

type Mutation {
  createUser(user:CreateUserInput):User
}
.......................................................................................................................................................................................................................................
									 GraphQL Application dev
........................................................................................................................................................................................................................................

You can write code in any language.

Java:
1.graphql-java
2.SpringBoot with GraphQL
3.DGS Framework-Netflix
etc...

JavaScript:

1.graphql-js.js
  The JavaScript reference implementation for GraphQL, a query language for APIs created by Facebook.

2.Apollo
  It is platform for building enterprise GraphQL apps
  The core of Apollo framework is written on the graphql.js and express.js

GraphQL application can be built using two arch
 1.monolith arch
 2.Microservices arch.

Apollo Core concepts:

  SuperGraph:
      Collection of small graphs called super graph
      A unified network of your organizations microservices and their data sources
      -All Composed into a single distributed API.

  SubGraph:
      It represents a single Graph application

  Graph OS:
     It is cloud platform which hosts super graph and router

   Router :
      It is composition api , clients will communicate only Router
     Router internally stiches the schema for data retrieval.

Components of Apollo:
.....................
1.Apollo Server : node js server written in express.js
2.Schema definitions - SDL
3.Resolvers - Schema Implementations like queries,mutations,subscription
4.Data Sources -  Database, rest api, any other apis.

Apollo code can be written in "JavaScript or typescript".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
....................................................................................................
			Apollo Project setup
....................................................................................

Required Softwares:

1.node.js latest version
2.vscode

Project setup :

....................................................................................................
			Apollo Project setup
....................................................................................

Required Softwares:

1.node.js latest version
2.vscode

Project setup :

Step 1:
\frontend>mkdir apollo-gettingstarted

Step 2:
\frontend>cd apollo-gettingstarted

\apollo-gettingstarted>npm init --yes
{
  "name": "apollo-gettingstarted",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}

Step 3:
\apollo-gettingstarted>code .

Step 4:install apollo server dependencies

npm install @apollo/server graphql

Step 5: install type script dependencies

npm i --save-dev typescript @types/node

  "dependencies": {
    "@apollo/server": "^4.10.5",
    "graphql": "^16.9.0"
  },
  "devDependencies": {
    "@types/node": "^20.14.12",
    "typescript": "^5.5.4"
  }

script:
In order to compile and run dev server in watch mode.

npm install --save-dev tsc-watch

package.json
  "scripts": {
    "start": "tsc-watch --onSuccess \"node ./dist/index.js"
  },

tsconfig.json
{
    "compilerOptions": {
        "rootDirs": [
            "src"
        ],
        "outDir": "dist",
        "lib": [
            "ES2020"
        ],
        "target": "ES2020",
        "module": "ESNext",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "types": [
            "node"
        ]
    }
}


Lets verify settings:

src/index.ts
 console.log('Hello GraphQL')

G:\Wipro\frontend\apollo-gettingstarted>npm start

SDL implementation:

Steps:

1.Define schema
2.Write biz logic for schema - Resolver
3.Start Apollo Server


Define schema:

There is two way to define schema in apollo
1.inside code 
2.outside code as separate file.










